{"pages":[{"title":"关于我","text":"这个人很神秘，什么都没有写。","link":"/about/index.html"},{"title":"","text":"videos - shuy98 .mainContainer { display: block; width: 90%; margin-left: auto; margin-right: auto; } /* @media screen and (min-width: 640px) { .mainContainer { display: block; width: 640px; margin-left: auto; margin-right: auto; } } */ .video-container2 { position: relative; margin-top: 8px; } .video-container2:before { display: block; content: \"\"; width: 100%; padding-bottom: 56.25%; } .video-container2 > div { position: absolute; top: 0; left: 0; right: 0; bottom: 0; } .video-container2 video { width: 100%; height: 100%; } .ref_text { font-style: italic; color: gray; } HLS Media Player Load Video based on videojs/http-streaming videojs.Vhs.GOAL_BUFFER_LENGTH = 400; videojs.Vhs.MAX_GOAL_BUFFER_LENGTH = 400; let player = videojs(\"my_video_1\"); $('#sURL').on(\"keyup\", function(e) { if (e.keyCode == 13) { load_source(); } }); function load_source() { let url_string = document.getElementById(\"sURL\").value; console.log(url_string); player = videojs(\"my_video_1\"); player.src({ type: \"application/x-mpegURL\", src: url_string }); player.hlsQualitySelector(); player.ready(function() { let myPlayer = this; myPlayer.play(); }); }","link":"/hls/index.html"}],"posts":[{"title":"这个视频被播放了xxx次","text":"本文可在Bilibili专栏阅读：cv7292636 前不久在YouTube上看到一则视频，来自著名YouTube艺人Tom Scott（B站搬运地址：BV1ZA411t7nK, YouTube地址：BxV14h0kFs0） &emsp;&emsp;这个视频有意思的地方在于，视频的标题准确“预测”了这个视频的播放量。对此，我很好奇他是怎么做到的，一番研究之后我有了答案，并且在B站也能轻易实现。原理只需要一句话就能概括：调用两次API，第一次通过HTTP的GET请求获得播放量，第二次通过POST将播放量更新至标题。下面我们一步一步来看。&emsp;&emsp;程序员小伙伴们对API一定不陌生，全称是应用程序编程接口。简单来说，它就是一部分预先定义的函数，我们无需了解函数具体的工作机制，只需根据接口的定义，就能轻松访问一组例程。下面这张图就展示了这个过程 &emsp;&emsp;不出所料，大家喜爱的B站也有“公开”的API哦。在Github上一番查找后，我决定使用以下两个Python库，分别来自@Passkou和@FortuneDayssss &emsp;&emsp;直接通过视频bv号调用视频信息API可以轻松获得播放量，具体代码如下， 123456789from bilibili_api import videofrom bilibiliuploader.bilibiliuploader import BilibiliUploaderimport osimport timeif __name__ == \"__main__\": bvid = \"BV1Hf4y1Q7CK\" v = video.get_video_info(bvid=bvid) views = v[\"stat\"][\"view\"] &emsp;&emsp;至此，第一步就完成了，仅仅用了10行代码。接下来是第二步，将播放量添加到标题。POST请求需要首先对用户身份进行验证，也就是用账号密码登录才能对自己视频进行标题变更操作。API同样提供了一个简单的接口，第一次通过账号密码登录后可以获得access token，之后使用access token登录，就可以对视频进行任意编辑操作了。 1234uploader = BilibiliUploader()dir_path = os.path.dirname(os.path.realpath(__file__))token_path = dir_path + \"/bililogin.json\"uploader.login_by_access_token_file(token_path) &emsp;&emsp;使用第一步获得的播放量，对标题进行编辑，再使用API发送POST请求更新就完成了。 123456parts = []uploader.edit( bvid=bvid, parts=parts, title='这个视频将会被播放' + str(views) + '次') &emsp;&emsp;最后，只需要在一定周期GET播放量，再POST新的标题就可以达到一种“预知”的效果了。这里就把周期设定为30秒，使用while循环执行，将脚本不间断运行在云服务器上。剩下的就是辛苦标题审核大大啦！小小完善后（控制更新频率）的完整代码如下， 123456789101112131415161718192021222324252627282930313233343536from bilibili_api import videofrom bilibiliuploader.bilibiliuploader import BilibiliUploaderimport os, timeif __name__ == \"__main__\": bvid = \"BV1Hf4y1Q7CK\" uploader = BilibiliUploader() dir_path = os.path.dirname(os.path.realpath(__file__)) token_path = dir_path + \"/bililogin.json\" prev_views = 0 while True: v = video.get_video_info(bvid=bvid) views = v[\"stat\"][\"view\"] if (views &gt; prev_views): uploader.login_by_access_token_file(token_path) if (views &lt; 10000): parts = [] uploader.edit( bvid=bvid, parts=parts, title=\"这个视频将会被播放\" + str(views) + \"次\" ) else: if (views - prev_views &gt; 1000): rounded_views = round(views / 10000, 1) parts = [] uploader.edit( bvid=\"BV1hD4y127PJ\", parts=parts, title=\"这个视频将会被播放\" + str(rounded_views) + \"万次\" ) prev_views = views time.sleep(30) 再次感谢@Passkou和@FortuneDayssss提供的API，有兴趣的小伙伴们也可以去支持一下他们哦。","link":"/2020/08/26/bilibili-title/"},{"title":"Linux Debian Repository结构及树莓派换源&#x2F;添加PPA","text":"在Debian以及其衍生的系统版本中，默认的软件包管理系统是 apt，一系列对软件的安装、卸载、升级等等操作都可以通过 apt执行。apt所需的获得软件列表、检查更新等操作依赖于软件源，这些源定义了从哪里去获得软件，源的URI定义在 /etc/apt/sources.list 文件以及 /etc/apt/sources.list.d 目录下。后者与前者的区别在于，前者为官方源文件，后者为一个目录，用于存放 .list 为结尾的文件，文件可任意命名，文件内容需遵循Debian定义的软件源文件格式。这个目录的主要目的就是方便增减额外的软件源，而不需要去改变官方源 sources.list，PPA (Personal Package Archive) 源文件通常会放在这个目录下。当然，将自定义软件源的URI添加到 sources.list也是起到同样的效果，但通常不这么做。下面两图分别展示了两者的内容。 Debian Repo Format通过查看 man page ，软件源格式定义如下， 1deb uri distribution [component1] [component2] [...] deb 声明了binary package的源，使用 deb-src 声明source package。binary package为编译完成的二进制文件，source package为所有源文件，需build from source，即在本地编译。 uri 声明软件源的根目录位置，例如树莓派交大源的URI http://mirrors.sjtug.sjtu.edu.cn/raspbian/raspbian/. distribution 声明了 $ARCHIVE_ROOT/dists 之下的子目录。以上方左图为例，distribution 为 buster，则子目录位置为 http://mirrors.sjtug.sjtu.edu.cn/raspbian/raspbian/dists/buster/. component 则为更深层的子目录，例如在树莓派Pi OS下有 main, non-free, contrib, 以及rpi。在Ubuntu下，主要有以下四种 Main - Canonical-supported free and open-source software. Universe - Community-maintained free and open-source software. Restricted - Proprietary drivers for devices. Multiverse - Software restricted by copyright or legal issues. 更多相关信息可查看 https://wiki.debian.org/DebianRepository/Format. 更换国内源国内访问官方源速度缓慢，因此会通常把官方源更换成国内镜像，一些高校、企业会有免费镜像站，可任意选择，替换 sources.list 内的文件即可。如Ubuntu，比较多人用的有清华源，阿里源等等。树莓派国内也有众多高校提供源，可通过官方链接查询。以树莓派Pi OS (buster)举例，个人使用的是交大源，做出如下变更。 123456# 编辑 `/etc/apt/sources.list` 文件，删除原文件所有内容，用以下内容取代：deb http://mirrors.sjtug.sjtu.edu.cn/raspbian/raspbian/ buster main non-free contrib rpideb-src http://mirrors.sjtug.sjtu.edu.cn/raspbian/raspbian/ buster main non-free contrib rpi# 编辑 `/etc/apt/sources.list.d/raspi.list` 文件，删除原文件所有内容，用以下内容取代：deb http://mirrors.sjtug.sjtu.edu.cn/raspberrypi/ buster main ui 关于添加PPA (Personal Package Archive)之前提到了PPA，顾名思义，通常为软件发行方自行管理的软件仓库。PPA为 .list 文件，并存放在 sources.list.d 目录下。使用如下方式即可， 1add-apt-repository [options] repository 其中 repository 为PPA格式 ppa:&lt;user&gt;/&lt;ppa-name&gt;。通常软件安装指导会提供详细步骤。","link":"/2020/12/25/pi-source-list/"},{"title":"树莓派Raspberry Pi OS Lite安装远程桌面VNC&#x2F;RDP","text":"使用的树莓派版本为4B，2G内存，Raspberry Pi OS Lite Buster，安装之前先进行更新 1sudo apt update &amp;&amp; sudo apt full-upgrade -y &amp;&amp; sudo apt clean 选择合适自己的桌面GUI，树莓派默认的桌面为PIXEL，Lite系统使用下面这个命令直接安装，Desktop无需再安装 1sudo apt install raspberrypi-ui-mods 也可选择其他桌面环境如xfce， 1sudo apt-get install xfce4 xfce4-terminal 关于各个GUI的详细比较可参照官方教程。 使用VNC远程访问桌面首先配置树莓派开启VNC服务，树莓派已自带RealVNC 1sudo raspi-config 进入 Interface Options -&gt; VNC -&gt; Enable，调整显示分辨率 Display Options -&gt; Resolution.设置完成后重启机器，VNC配置完成。接下来只需根据所使用的平台下载VNC客户端，树莓派推荐使用RealVNC Viewer，输入树莓派的IP地址即可连接远程桌面。 使用RDP远程访问桌面RDP是由Microsoft开发的协议，Windows下可直接使用Remote Desktop客户端连接，无需额外安装。 1sudo apt-get install xrdp 默认端口为3389，可通过配置文件更改 /etc/xrdp/xrdp.ini。客户端使用 IP:Port即可连接远程桌面。以下为控制命令 123456sudo service xrdp status # 查看状态sudo service xrdp start # 启动服务sudo service xrdp stop # 停止服务sudo service xrdp restart # 重启服务sudo update-rc.d xrdp disable # 关闭开机自启sudo update-rc.d xrdp enable # 开启开机自启","link":"/2020/12/22/pi-VNC-RDP/"},{"title":"配置自己的流媒体服务：关于MPEG-DASH&#x2F;HLS","text":"自从开始使用云服务器之后，因为内网带宽非常好，便经常会在服务器上直接下载视频。观看视频通常有两个选择，一个便是下载到本地然后使用本地播放器播放，另一个是直接用http请求视频文件（如MP4），在浏览器直接播放。两者都有各自的缺点，也不符合如今主流的流媒体播放方式。这篇文章会重点讲讲流媒体所使用的 MPEG-DASH/HLS，以及如何在自己的服务器上进行配置。 相关名词码率/比特率（Bitrate）: 单位时间内传输的信息，通常用 bps (bit per second)表示。视频码率可以理解为单位时间内传输的数据越多，画面包含的细节信息越多，质量也就越高。分辨率（Resolution）: 每帧画面像素点的数量。常见的如 720P (1280x720)、1080P (1920x1080)都是这个含义。高分辨率不代表高画质，若码率较低，画面会有糊成一团的观感。帧率（FPS）: 每秒钟包含的帧数。常见的有24帧、60帧等等。帧率越高画面越连贯丝滑。 网络视频播放技术HTTP Download最初的方式，浏览器请求资源，资源下载完成后由本地播放器进行播放。优点是架构非常简单，缺点是必须等待完整视频下载完成后才能开始播放。 HTTP Progressive Download对之前的方式的改进，不再是浏览器与服务交换信息，而是播放器直接与服务器建立TCP连接，好处在于只要有足够的视频帧，就可以直接开始播放视频，无需等待整部视频下载完成。预先下载的视频帧会放在缓冲区（Buffer）内。播放器与服务器的连接依赖 Meta File，该文件由浏览器先向服务器发起请求获得。根据下图表示，大体上为三步， 浏览器向服务器请求 Meta File，该文件描述了视频相关的信息。 浏览器传递 Meta File 给媒体播放器。 媒体播放器读取 Meta File 信息，并与服务器建立TCP连接、请求视频文件。 这里开始引入视频缓冲（Buffer），在边下载边播放时要保证缓冲区有足够的视频帧，否则就会出现我们看到的视频卡顿现象，以等待缓存区积累一定数量的视频帧后继续播放视频。 Progressive Download 也有着明显的缺点，一个是对seek不友好，比如要随意定位到视频的某个时间点，会出现长时间等待来下载额外不需要的视频帧。而且无法实时改变视频码率来适应不同的网络状况，通常要在的下载之前确定视频的码率。之后的HTTP Streaming就解决了这些问题。 Real-Time Streaming (RTSP)第二代技术，实时流媒体协议，为L7应用层协议，不同于HTTP协议。RTSP允许TCP或UDP做为控制信息的传输协议。大体上架构设计与Progressive Download非常类似。RTSP属于一种Custom Streaming Protocol，缺点也十分明显，例如路由器可能会处于安全原因阻止非HTTP的协议，防火墙阻止UDP协议，无法利用HTTP代理和缓存的优势等等。这些都会导致Custom Streaming Protocol无法很好地适应复杂的互联网环境。 HTTP Streaming第三代技术，适应性的流媒体播放技术，也是如今主流的流媒体播放网站所使用的。该架构以客户端为核心，完全使用标准的Web Server服务和HTTP协议，即stateless server，以及stateful client。视频被分成多个时长相同的分段（Chunk），每个分段都始于关键帧（Keyframe）来保证互相独立。客户端按需下载视频分段，再按顺序播放来观看连续视频。 Adaptive Bit Rate 可对视频分段进行不同码率的编码，码率越高画面损失越小，文件体积也就越大，再根据不同客户的网络带宽，适应性选择对应的版本。很多视频网站都支持清晰度选择，例如流畅、清晰、高清，超清等等，就是这个道理。因为Chunk Boundary相同，不同码率的视频可以无缝衔接。这就能够让高带宽的网络选择码率更高的视频，也能让低带宽的网络流畅播放码率较低的视频。 举个具体的例子，例如一个视频分段的长度为10秒钟，将其编码为三个版本：流畅、高清，和超清，体积大小分别对应20Mb、50Mb, 还有100Mb。从应用程序的角度出发，网络带宽是不可见的，只能通过下载一个分段的大小和时间来估计。假设下载20Mb的分段用了4秒钟，我们就可以估计网络带宽大约为5Mbps。根据此估计来选择下一个要下载分段的码率。可以有很多不同的适应性算法，这里不介绍。 实现这一切同样依赖于一个 Manifest File，该描述文件记录了视频时长、分段码率、分段URL等信息，客户端根据这个文件对对应的分段发起请求，流程如下图所示。 HTTP Streaming 有一个很大的优势在于它使用了互联网广泛使用的HTTP协议和Web Server架构，使得它可以利用现存的防火墙、缓存、代理、CDN等带来的优势。同时它将大的视频文件细分成多个小型且独立分段和多种码率选择，对Seek以及不同的网络环境非常友好。例如来自Apple的HTTP Live Streaming (HLS)，还有Dynamic Adaptive Streaming over HTTP (MPEG-DASH)都是现在广泛使用的协议。 HLS实现搭建的环境及依赖如下， 平台： Ubuntu 18.04 LTSWeb Server： Nginx 1.14.0依赖： ffmpeg v3.4.8 videojs/http-streaming v2.4.1 videojs-contrib-quality-levels v2.0.9 videojs-hls-quality-selector v1.1.4 这里选用了videojs/http-streaming，它提供了播放器的封装和简单易用的API，只需声明Manifest File的地址即可播放HSL协议的视频，核心代码如下，具体Demo详见 https://blog.shuy98.com/hls/ 1234567891011121314&lt;!-- HTML --&gt;&lt;div&gt; &lt;video-js name=\"videoElement\" id=\"my_video_1\" class=\"vjs-default-skin vjs-big-play-centered\" controls preload=\"none\" width=\"1280\" height=\"720\" &gt; &lt;source id=\"source_url\" src=\"\" type=\"application/x-mpegURL\" /&gt; &lt;/video-js&gt;&lt;/div&gt; videojs-contrib-quality-levels和videojs-hls-quality-selector则提供了清晰度选项的API。 12345678// JavaScriptplayer = videojs(\"my_video_1\");player.src({ type: \"application/x-mpegURL\", src: url_string });player.hlsQualitySelector();player.ready(function() { let myPlayer = this; myPlayer.play();}); 视频文件HLS分段处理用ffmpeg对视频进行HLS编码处理，可将原视频进行不同分辨率以及音视频的编码并分段，然后输出Manifest文件，再HLS协议中是以 .m3u8 为后缀的文件。下面的代码将原视频 input.mp4 以10秒钟为单位长度进行分段，保留原视频编码，并输出描述文件 720p.m3u8。分段视频文件的后缀则为 .ts。 1ffmpeg -i input.mp4 -codec: copy -s 1280x720 -start_number 0 -hls_time 10 -hls_list_size 0 -f hls 720p.m3u8 ffmpeg有非常多的选项，详细信息可参考官方文档 ffmpeg Documentation。对于多个码率选择，使用类似的脚本生成多个不同的视频版本，每个版本对应一个Manifest文件，然后创建一个Master Manifest，其中声明不同视频版本对应的分辨率、所需带宽、帧率等等信息，方便媒体播放器适应性选择对应的视频分段。Master Manifest创建规则详见：Apple HLS: Creating A Master Playlist。","link":"/2021/01/05/dash-hls/"},{"title":"Sadowsocks 客户端&#x2F;服务端配置","text":"服务端 方式一 在目标服务器上用自动化安装脚本配置Shadowsocks: Github repo. 根据脚本提示配置端口、密码、加密等等。 后续如需编辑端口号、密码等信息，直接编辑/etc/shadowsocks.json即可。 注：脚本需要从GitHub进行wget，确认ca-certificates和ssl-cert已安装。 方式二 使用官方 shadowsocks-libev 提供的docker容器，直接从docker hub上pull镜像: shadowsocks/shadowsocks-libev/，同方式一编辑/etc/shadowsocks-libev/config.json配置端口号密码等信息后，启动docker镜像即可。 方式三 以Ubuntu为例，直接安装或Build from source。详细参照官方文档： shadowsocks-libev README 12sudo apt updatesudo apt install shadowsocks-libev 配置文件位置同方式二，启动使用如下脚本 1sudo systemctl start shadowsocks-libev.service 开机自启 1sudo systemctl enable shadowsocks-libev.service 配置文件举例12345678{ \"server\":\"0.0.0.0\", # IPv6 则使用 \"::\" \"server_port\":8388, \"password\":\"password\", \"timeout\":60, \"method\":\"aes-128-gcm\", \"mode\":\"tcp_and_udp\"} 客户端根据操作系统下载对应客户端即可，客户端配置输入目标服务器的IP、端口号、加密方式、密码等信息即可建立连接。官方客户端链接：https://shadowsocks.org/en/download/clients.html 代理配置文件翻墙直接使用默认配置文件即可，按需增减规则。若回国，根据操作系统平台可使用以下代理配置，收集自网络，经过自行编辑，按需增减规则 Windows: https://raw.githubusercontent.com/shuy98/ss_rule/master/pac.txt Android: https://raw.githubusercontent.com/shuy98/ss_rule/master/rule.txt iOS Shadowrocket: https://raw.githubusercontent.com/shuy98/ss_rule/master/go_home.conf","link":"/2020/09/08/ss-rule/"},{"title":"Nginx下如何获取SSL&#x2F;TLS泛域名证书","text":"什么是SSL/TLS我们浏览网页的时候，大部分网页的URL边上会有一个锁的标志，这表面我们与该服务器之间的连接是安全的。将流量加密是一种保证连接安全的手段，就算被劫持，流量中的隐私信息也不会被泄露。SSL/TLS协议就是为了达到这样的目的。现如今信息安全很重要，因此越来越多的网站会默认使用SSL/TLS来保证与客户间的通信安全。HTTPS使用了SSL/TLS进行流量加密，默认443端口。 加密方式SSL会用到两种主要的加密方式：对称加密、非对称加密。对称加密只使用一把key，这把key同时用于加密和解密。非对称加密使用一对key，私匙(Private Key)和公匙(Public Key)。Public Key，顾名思义是公开的Key，能用于解密其对应Private Key加密的密文。举个例子，有信息X，以及一对Key，X_pub和X_priv。可以用其中一把(例如X_priv)对信息进行加密得到X的密文，并用另外一把(例如X_pub)对信息进行解密得到X。非堆成加密效率低于对称加密。 证书颁发机构CA（Certificate Authority）CA会使用其Private Key将网站相关信息加密，并颁发证书Certificate。CA的Public Key已经预加载在操作系统或浏览器中，可以直接解密证书获取站点信息。企业会向部分CA付费获取专门的服务，当然也有免费的CA如Let’s Encrypt。 证书（Certificate）包含站点的相关信息，如DNS Name，Public Key，CA Name，其他相关信息，以及CA签名。CA的签名就是CA使用其Private Key对上述所有信息进行加密后得到的密文，可通过CA的Public解密。 TLS1.2握手过程有了以上部分，信息加密便可通过证书轻松实现了，具体流程如下。 TLS建立在TCP之上，因此先完成常规的TCP三次握手。 ClientHello: 客户端发起“hello”请求，包含支持的TLS最高版本，支持的cipher suites(加密算法列表)，以及一串随机的字节client random。 ServerHello: 服务端回复请求，包含证书，服务端选择使用的cipher suite，以及一串随机的字节server random。 Authentication: 客户端通过证书确认服务端身份，使用CA的Public Key解密证书签名，以获取服务端Public Key。 The premaster secret: 客户端发送一串或多串随机字节，作为“premaster secret”。这段信息使用服务端的Public Key加密，只能通过服务端的Private Key解密。 Private key used: 服务端使用Private Key解密得到premaster secret。 Session Key: 双方可使用client random、server random，以及premaster secret生成相同的session/secret key。 Client ready: 客户端发送Finished，包含此前全部信息，并使用session key加密。这是第一段使用session key加密的信息。 Server ready: 服务端同样发送Finished，包含此前全部信息，并使用session key加密。 握手完成，连接建立完毕，双方使用session key对信息进行对称加密，继续后续通信。 并非所有TLS握手会用到private key来生成session key，详见Diffie-Hellman handshake process。以上保证了客户端和服务端之间的通信安全。证书和握手这个过程保证了站点不可被仿冒。浏览器若提示网站证书有问题，并且我们会和网站交换敏感信息，一定要确认网站安全。 获取个人泛域名的SSL/TLS证书（Let’s Encrypt）这里我们使用知名的免费的CA：Let’s Encrypt，并借助certbot自动获取证书。 123# sudo add-apt-repository ppa:certbot/certbot (deprecated)# sudo apt-get install python-certbot-nginx (deprecated)sudo apt-get install python3-certbot-nginx 使用一下命令直接获得泛域名证书，将example.com替换为自己的域名 1sudo certbot --server https://acme-v02.api.letsencrypt.org/directory -d *.example.com --manual --preferred-challenges dns-01 certonly 将生成的DNS TXT部署到域名DNS管理页面下即可。证书会放在/etc/letsencrypt/live/example.com/目录下，将Nginx配置文件中的证书位置指向该目录即可。 注意：证书的有效期限为3个月，临近到期时使用以上命令renew或直接在命令行执行certbot renew，也有自动renew方法，这里不描述。证书更新后需reload Web Server以加载新的证书。","link":"/2020/10/01/ssl-nginx/"},{"title":"理解安卓 Activity 生命周期","text":"安卓 Activity 的生命周期包含了很多状态，每一种都有其对应的回调函数，其中有 onCreate(), onStart(), onResume(), onPause(), onRstart(), onStop(), 以及 onDestroy(). 下面这张来自官方文档的状态图归纳了各个状态之间的转移， 关于各种状态切换会在什么情况下出现，以及这些回调函数何时被调用，参考下表总结， 回调函数 何时调用 下一状态 onCreate() Activity初次启动时；通常会在该方法中进行静态设置，init变量，setContentView等等；该函数有一个 Bundle savedInstanceState 参数，为保存的状态（在函数 onSaveInstanceState() 调用时），用来恢复活动状态。 onStart() onRestart() 于onStop()过渡至onStart()。 onStart() onStart() 在 Activity 变为可见之前。若 Activity 接着进入前台则紧接onResume()。若 Activity 接着变为不可见，可直接跳至onStop()。 onResume() 或 onStop() onResume() 在 Activity 进入前台之前。 onPause() onPause() 当另一个 Activity 进入 Resume 状态（进入前台）。若当前 Activity 返回前台则紧跟 onResume()，若变为不可见则紧跟onStop()。 onResume() 或 onStop() onStop() 在 Activity 变为不可见之前。不可见可以是由于被其它 Activity 遮挡或是因为即将转至结束。若当前 Activity 又恢复可见则紧跟 onRestart()，若即将结束或Destroy则 onDestroy()。 onRestart() 或 onDestroy() onDestroy() 在 Activity 即将结束或被Destroy之前。 无 函数 onSaveInstanceState() 会在 onStop() 之前被调用。 Activity 初次启动时参数 savedInstanceState 为 null。在 onSaveInstanceState() 保存状态后才不为 null，因此需检查。 下面三图分别展示了可见、不可见，以及跳出前台的情况。","link":"/2021/01/12/andoird-activity-lifecycle/"},{"title":"使用diskpart压缩WSL2虚拟磁盘空间","text":"WSL2是Windows平台在一个轻量的虚拟环境下运行完整的Linux内核，除了与Windows文件系统的I/O性能，其余表现几乎完美。WSL2使用了Virtual Disk（VHDX）来储存文件系统，会按需扩大储存空间，但缺点在于磁盘并不会自动释放空间。这造成的结果便是长期使用后会（比如docker image）发现WSL2占据了大量的硬盘空间。本文就介绍一种使用PowerShell下diskpart工具来手动释放虚拟磁盘空间。 1. 检查虚拟机状态在PowerShell键入如下命令查看WSL2虚拟机是否在运行 1wsl --list --verbose 如果为Running，先保存/备份重要信息后，使用如下命令中止运行，其中&lt;NAME&gt;为虚拟机的名称，以上图为例，名称为Ubuntu 1wsl --terminate &lt;NAME&gt; 2. 定位虚拟磁盘VHDX位置WSL2实例的Package目录所在位置如下，其中&lt;username&gt;为Windows本机用户名 1C:\\Users\\&lt;username&gt;\\AppData\\Local\\Packages 再根据所使用虚拟机的Vendor Name找对应目录，以Ubuntu举例，目录为CanonicalGroupLimited。完整目录如下 1C:\\Users\\&lt;username&gt;\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\\LocalState\\ext4.vhdx 3. 使用diskpart压缩虚拟磁盘在PowerShell中输入diskpart来启动工具，然后使用select vdisk来选中虚拟磁盘 12select vdiskfile=\"C:\\Users\\&lt;username&gt;\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\\LocalState\\ext4.vhdx\" 看到选中成功后输入 1compact vdisk 等待压缩完成，退出diskpart，至此空间释放完成。","link":"/2021/02/13/shrink-wsl2/"},{"title":"Nginx开启RTMP并实现浏览器HLS Streaming","text":"注：本文后半实现HLS Streaming细节详见前文 配置自己的流媒体服务：关于MPEG-DASH/HLS 最近入手了一台DJI OSMO Action，在学习使用各种功能的时候发现可以进行直播，使用的是常见的RTMP协议。于是我转念一想，之前搞过HLS/MPEG-Dash，不如试试同时实现RTMP推流来配合HLS，应该会很有意思。 本文大量参考来自Nginx官方博文 Enabling Video Streaming for Remote Learning with NGINX and NGINX Plus。 环境配置 OS: Ubuntu 20.04 LTSNginx: 1.19.10 安装RTMP模块官方博客直接通过build from source来安装配置Nginx以及RTMP模块，详见原文。个人之前已在运行Nginx服务器，并且是通过apt安装的，因此本文也使用apt来安装RTMP模块。使用以下命令，适用于Ubuntu 18.04及以上版本。安装完成后重启Nginx服务生效。 1sudo apt install libnginx-mod-rtmp 配置nginx.conf编辑nginx.conf配置文件，默认位置为/etc/nginx/，添加如下配置 12345678910111213141516171819202122rtmp { server { listen 1935; # 默认监听端口 application live { # RTMP Application 命名为live，可自定义为其他 live on; # 开启直播 interleave on; # 音视频通过同一个RTMP chunk stream传输 record off; # 关闭录制 exec ffmpeg -i rtmp://localhost/live -vcodec libx264 -vprofile baseline -acodec aac -strict -2 -f flv rtmp://localhost/live/stream; hls on; # 开启HLS hls_path /tmp/hls_live; # 视频分段存放位置 hls_fragment 5s; # Fragment时长 dash on; # 开启MPEG-Dash dash_path /tmp/dash_live; dash_fragment 5s; } }} 重启之后便已实现最基本的RTMP协议了，在OBS或等同支持RTMP协议的软件下输入URI： 1rtmp://yourdomain.com/live 即实现推流。可使用支持RTMP协议的播放器例如VLC Player，输入相同URI即可观看直播。 浏览器观看步骤一尽管完成了之前的步骤，但在很多情况下还是不方便使用，要是能通过浏览器随时随地观看就好了。可以通过下面的方法实现，注意到上面的application中有一段代码 123exec ffmpeg -i rtmp://localhost/live -vcodec libx264 -vprofile baseline -acodec aac -strict -2 -f flv rtmp://localhost/live/stream; 这里使用了ffmpeg，通过之前介绍流媒体的文章应该见过这个工具，它实际做的就是对视频进行转码，并将视频分段保存在我们配置的位置中，再配合之前实现的HLS/MPEG-Dash来达到浏览器播放的目的。将ffmpeg的脚本放在该application context下可以在RTMP推流建立完成后自动开启转码，无需监管服务器并手动开启。 步骤二进入服务器的配置文件，即编辑/etc/nginx/site-available/yourdomain.com文件，在 server 下添加 12345678910location /hls_live { root /tmp; try_files $uri $uri/ =404;}location /live { add_header Cache-Control no-cache; add_header Access-Control-Allow-Origin \"*\"; root /var/www/yourdomain.com;} 其中/hls_live指向开始时配置的视频分段存放地址，即/tmp/hls_live，该地址不通过浏览器直接访问。而/live则指向之前配置了videojs来实现HLS的HTML文件所在的位置，使用浏览器直接访问https://yourdomain.com/live查看HTML页面。其中videojs将src指向https://yourdomain.com/hls_live来查找并播放HLS视频分段。 123456789101112131415161718192021222324&lt;!-- HTML --&gt;&lt;div&gt; &lt;video-js name=\"videoElement\" id=\"my_video_1\" class=\"vjs-default-skin vjs-big-play-centered\" controls preload=\"none\" width=\"1280\" height=\"720\" &gt; &lt;source id=\"source_url\" src=\"https://yourdomain.com/hls_live\" type=\"application/x-mpegURL\" /&gt; &lt;/video-js&gt;&lt;/div&gt;&lt;!-- JavaScript --&gt;&lt;script&gt; let player = videojs(\"my_video_1\"); player.ready(function() { let myPlayer = this; myPlayer.play(); });&lt;/script&gt; 测试发现在iOS的Safari浏览器下直接访问https://yourdomain.com/hls_live可直接播放视频。 相关链接相关RTMP配置教程：https://docs.peer5.com/guides/setting-up-hls-live-streaming-server-using-nginx/ffmpeg配置：https://licson.net/post/setting-up-adaptive-streaming-with-nginx/Nginx RTMP官方博文：https://www.nginx.com/blog/video-streaming-for-remote-learning-with-nginx/","link":"/2021/05/06/rtmp-nginx/"},{"title":"Digital Ocean命令行CLI配置VPS&#x2F;刷新公有IP","text":"在当前不稳定的网络环境下，VPS的IP地址可能会随时被墙，访问Digital Ocean的Web Console也会时常不可用。本文记录了Digital Ocean的CLI的一些基本操作，可在不方便的情况下使用命令行（例如使用各类云服务商的境外实例）更新公有IP地址。 安装配置CLI 官方说明：https://docs.digitalocean.com/reference/doctl/how-to/install/ 安装CLI在Linux/macOS系统下，运行一下命令获得CLI二进制文件 12345678# 从GitHub下载最新Binarywget https://github.com/digitalocean/doctl/releases/download/v1.60.0/doctl-1.60.0-linux-amd64.tar.gz# 解压tar xf ~/doctl-1.60.0-linux-amd64.tar.gz# 移动至/usr/local/binsudo mv ~/doctl /usr/local/bin 获取权限到控制台创建API Key，并保存到安全位置，Key只会显示一次。运行以下命令，并根据提示输入API Key来获取权限。 1doctl auth init 相关流程 官方文档：https://docs.digitalocean.com/reference/doctl/reference/ 查看/创建Snapshot若Droplet无需备份，且已有可用Snapshot则跳过此步骤 12345678910111213141516# 列出所有Droplet，获取目标IDdoctl compute droplet list# 停止Dropletdoctl compute droplet-action power-off &lt;droplet-id&gt;# 创建Snapshot用于后续还原# --snapshot-name 还原点名称# --wait 等待完成doctl compute droplet-action snapshot &lt;droplet-id&gt; --snapshot-name my-server-snapshot --wait# 列出所有还原点doctl compute snapshot list# 删除还原点doctl compute snapshot delete &lt;snapshot-id&gt; 创建Droplet12345678910111213# 列出所有Droplet，获取目标IDdoctl compute droplet list# 删除Dropletdoctl compute droplet delete &lt;droplet-id&gt;# 获取目标还原点IDdoctl compute snapshot list# 使用还原点创建新的Droplet# --size droplet大小，这里使用最小s-1vcpu-1gb# --region droplet地区，这里使用sfo3doctl compute droplet create --image &lt;snapshot-id&gt; --size s-1vcpu-1gb --region sfo3 &lt;server-name&gt; 在创建Droplet的命令中可以添加--wait来等待完成。默认为异步，创建完成后会收到邮件，邮件内包含公有IP。 更新DNS记录若有使用域名，且有使用Digital Ocean的Nameserver，使用以下命令更新DNS记录，让域名指向新的IP，若无则可跳过此步骤，直接使用Public IP。 12345# 列出所有记录doctl compute domain records list &lt;yourdomain.com&gt;# 更新记录内容为新的IPdoctl compute domain records update &lt;yourdomain.com&gt; --record-id &lt;record-id&gt; --record-data &lt;ip-address&gt;","link":"/2021/06/03/doctl/"}],"tags":[{"name":"API","slug":"API","link":"/tags/API/"},{"name":"树莓派","slug":"树莓派","link":"/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"科学上网","slug":"科学上网","link":"/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"Android","slug":"Android","link":"/tags/Android/"}],"categories":[{"name":"不正经的内容","slug":"不正经的内容","link":"/categories/%E4%B8%8D%E6%AD%A3%E7%BB%8F%E7%9A%84%E5%86%85%E5%AE%B9/"},{"name":"正经的内容","slug":"正经的内容","link":"/categories/%E6%AD%A3%E7%BB%8F%E7%9A%84%E5%86%85%E5%AE%B9/"}]}