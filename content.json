{"pages":[{"title":"关于我","text":"不喜欢写东西，所以这里什么也没有。","link":"/about/index.html"}],"posts":[{"title":"这个视频被播放了xxx次","text":"本文可在Bilibili专栏阅读：cv7292636 前不久在YouTube上看到一则视频，来自著名YouTube艺人Tom Scott（B站搬运地址：BV1ZA411t7nK, YouTube地址：BxV14h0kFs0） &emsp;&emsp;这个视频有意思的地方在于，视频的标题准确“预测”了这个视频的播放量。对此，我很好奇他是怎么做到的，一番研究之后我有了答案，并且在B站也能轻易实现。原理只需要一句话就能概括：调用两次API，第一次通过HTTP的GET请求获得播放量，第二次通过POST将播放量更新至标题。下面我们一步一步来看。&emsp;&emsp;程序员小伙伴们对API一定不陌生，全称是应用程序编程接口。简单来说，它就是一部分预先定义的函数，我们无需了解函数具体的工作机制，只需根据接口的定义，就能轻松访问一组例程。下面这张图就展示了这个过程 &emsp;&emsp;不出所料，大家喜爱的B站也有“公开”的API哦。在Github上一番查找后，我决定使用以下两个Python库，分别来自@Passkou和@FortuneDayssss &emsp;&emsp;直接通过视频bv号调用视频信息API可以轻松获得播放量，具体代码如下， 123456789from bilibili_api import videofrom bilibiliuploader.bilibiliuploader import BilibiliUploaderimport osimport timeif __name__ == \"__main__\": bvid = \"BV1Hf4y1Q7CK\" v = video.get_video_info(bvid=bvid) views = v[\"stat\"][\"view\"] &emsp;&emsp;至此，第一步就完成了，仅仅用了10行代码。接下来是第二步，将播放量添加到标题。POST请求需要首先对用户身份进行验证，也就是用账号密码登录才能对自己视频进行标题变更操作。API同样提供了一个简单的接口，第一次通过账号密码登录后可以获得access token，之后使用access token登录，就可以对视频进行任意编辑操作了。 1234uploader = BilibiliUploader()dir_path = os.path.dirname(os.path.realpath(__file__))token_path = dir_path + \"/bililogin.json\"uploader.login_by_access_token_file(token_path) &emsp;&emsp;使用第一步获得的播放量，对标题进行编辑，再使用API发送POST请求更新就完成了。 123456parts = []uploader.edit( bvid=bvid, parts=parts, title='这个视频将会被播放' + str(views) + '次') &emsp;&emsp;最后，只需要在一定周期GET播放量，再POST新的标题就可以达到一种“预知”的效果了。这里就把周期设定为30秒，使用while循环执行，将脚本不间断运行在云服务器上。剩下的就是辛苦标题审核大大啦！小小完善后（控制更新频率）的完整代码如下， 123456789101112131415161718192021222324252627282930313233343536from bilibili_api import videofrom bilibiliuploader.bilibiliuploader import BilibiliUploaderimport os, timeif __name__ == \"__main__\": bvid = \"BV1Hf4y1Q7CK\" uploader = BilibiliUploader() dir_path = os.path.dirname(os.path.realpath(__file__)) token_path = dir_path + \"/bililogin.json\" prev_views = 0 while True: v = video.get_video_info(bvid=bvid) views = v[\"stat\"][\"view\"] if (views &gt; prev_views): uploader.login_by_access_token_file(token_path) if (views &lt; 10000): parts = [] uploader.edit( bvid=bvid, parts=parts, title=\"这个视频将会被播放\" + str(views) + \"次\" ) else: if (views - prev_views &gt; 1000): rounded_views = round(views / 10000, 1) parts = [] uploader.edit( bvid=\"BV1hD4y127PJ\", parts=parts, title=\"这个视频将会被播放\" + str(rounded_views) + \"万次\" ) prev_views = views time.sleep(30) 再次感谢@Passkou和@FortuneDayssss提供的API，有兴趣的小伙伴们也可以去支持一下他们哦。","link":"/2020/08/25/bilibili-title/"},{"title":"Sadowsocks 客户端&#x2F;服务端配置","text":"服务端 方式一 在目标服务器上用自动化安装脚本配置Shadowsocks: Github repo. 根据脚本提示配置端口、密码、加密等等。 后续如需编辑端口号、密码等信息，直接编辑/etc/shadowsocks.json即可。 注：脚本需要从GitHub进行wget，确认ca-certificates和ssl-cert已安装。 方式二 使用 @teddysun 提供的docker容器，直接从docker hub上pull镜像: teddysun/shadowsocks-libev/，同方式一编辑/etc/shadowsocks-libev/config.json配置端口号密码等信息后，启动docker镜像即可。 客户端根据操作系统下载对应客户端即可，客户端配置输入目标服务器的IP、端口号、加密方式、密码等信息即可建立连接。官方客户端链接：https://shadowsocks.org/en/download/clients.html 代理配置文件翻墙直接使用默认配置文件即可，按需增减规则。若回国，根据操作系统平台可使用以下代理配置，收集自网络，经过自行编辑，按需增减规则 Windows: https://raw.githubusercontent.com/shuy98/ss_rule/master/pac.txt Android: https://raw.githubusercontent.com/shuy98/ss_rule/master/rule.txt iOS Shadowrocket: https://raw.githubusercontent.com/shuy98/ss_rule/master/go_home.conf","link":"/2020/09/08/ss-rule/"},{"title":"Nginx下如何获取SSL&#x2F;TLS泛域名证书","text":"什么是SSL/TLS我们浏览网页的时候，大部分网页的URL边上会有一个锁的标志，这表面我们与该服务器之间的连接是安全的。将流量加密是一种保证连接安全的手段，就算被劫持，流量中的隐私信息也不会被泄露。SSL/TLS协议就是为了达到这样的目的。现如今信息安全很重要，因此越来越多的网站会默认使用SSL/TLS来保证与客户间的通信安全。HTTPS使用了SSL/TLS进行流量加密，默认443端口。 加密方式SSL会用到两种主要的加密方式：对称加密、非对称加密。对称加密只使用一把key，这把key同时用于加密和解密。非对称加密使用一对key，私匙(Private Key)和公匙(Public Key)。Public Key，顾名思义是公开的Key，能用于解密其对应Private Key加密的密文。举个例子，有信息X，以及一对Key，X_pub和X_priv。可以用其中一把(例如X_priv)对信息进行加密得到X的密文，并用另外一把(例如X_pub)对信息进行解密得到X。非堆成加密效率低于对称加密。 证书颁发机构CA（Certificate Authority）CA会使用其Private Key将网站相关信息加密，并颁发证书Certificate。CA的Public Key已经预加载在操作系统或浏览器中，可以直接解密证书获取站点信息。企业会向部分CA付费获取专门的服务，当然也有免费的CA如Let’s Encrypt。 证书（Certificate）包含站点的相关信息，如DNS Name，Public Key，CA Name，其他相关信息，以及CA签名。CA的签名就是CA使用其Private Key对上述所有信息进行加密后得到的密文，可通过CA的Public解密。 TLS1.2握手过程有了以上部分，信息加密便可通过证书轻松实现了，具体流程如下。 TLS建立在TCP之上，因此先完成常规的TCP三次握手。 ClientHello: 客户端发起“hello”请求，包含支持的TLS最高版本，支持的cipher suites(加密算法列表)，以及一串随机的字节client random。 ServerHello: 服务端回复请求，包含证书，服务端选择使用的cipher suite，以及一串随机的字节server random。 Authentication: 客户端通过证书确认服务端身份，使用CA的Public Key解密证书签名，以获取服务端Public Key。 The premaster secret: 客户端发送一串或多串随机字节，作为“premaster secret”。这段信息使用服务端的Public Key加密，只能通过服务端的Private Key解密。 Private key used: 服务端使用Private Key解密得到premaster secret。 Session Key: 双方可使用client random、server random，以及premaster secret生成相同的session/secret key。 Client ready: 客户端发送Finished，包含此前全部信息，并使用session key加密。这是第一段使用session key加密的信息。 Server ready: 服务端同样发送Finished，包含此前全部信息，并使用session key加密。 握手完成，连接建立完毕，双方使用session key对信息进行对称加密，继续后续通信。 并非所有TLS握手会用到private key来生成session key，详见Diffie-Hellman handshake process。以上保证了客户端和服务端之间的通信安全。证书和握手这个过程保证了站点不可被仿冒。浏览器若提示网站证书有问题，并且我们会和网站交换敏感信息，一定要确认网站安全。 获取个人泛域名的SSL/TLS证书（Let’s Encrypt）这里我们使用知名的免费的CA：Let’s Encrypt，并借助certbot自动获取证书。 123sudo add-apt-repository ppa:certbot/certbotsudo apt-get updatesudo apt-get install python-certbot-nginx 使用一下命令直接获得泛域名证书，将example.com替换为自己的域名 1sudo certbot --server https://acme-v02.api.letsencrypt.org/directory -d *.example.com --manual --preferred-challenges dns-01 certonly 将生成的DNS TXT部署到域名DNS管理页面下即可。证书会放在/etc/letsencrypt/live/example.com/目录下，将Nginx配置文件中的证书位置指向该目录即可。 注意：证书的有效期限为3个月，临近到期时使用以上命令renew，也有自动renew方法，这里不描述。","link":"/2020/09/30/ssl-nginx/"}],"tags":[{"name":"API","slug":"API","link":"/tags/API/"},{"name":"科学上网","slug":"科学上网","link":"/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"}],"categories":[{"name":"不正经的内容","slug":"不正经的内容","link":"/categories/%E4%B8%8D%E6%AD%A3%E7%BB%8F%E7%9A%84%E5%86%85%E5%AE%B9/"},{"name":"正经的内容","slug":"正经的内容","link":"/categories/%E6%AD%A3%E7%BB%8F%E7%9A%84%E5%86%85%E5%AE%B9/"}]}