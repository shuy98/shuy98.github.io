{"pages":[{"title":"关于我","text":"这个人很神秘，什么都没有写。","link":"/about/index.html"},{"title":"hls2","text":"","link":"/hls2/hls2.html"},{"title":"","text":"videos - shuy98 .mainContainer { display: block; width: 90%; margin-left: auto; margin-right: auto; } /* @media screen and (min-width: 640px) { .mainContainer { display: block; width: 640px; margin-left: auto; margin-right: auto; } } */ .video-container2 { position: relative; margin-top: 8px; } .video-container2:before { display: block; content: \"\"; width: 100%; padding-bottom: 56.25%; } .video-container2 > div { position: absolute; top: 0; left: 0; right: 0; bottom: 0; } .video-container2 video { width: 100%; height: 100%; } .ref_text { font-style: italic; color: gray; } HLS Media Player Load Video based on videojs/http-streaming videojs.Vhs.GOAL_BUFFER_LENGTH = 400; videojs.Vhs.MAX_GOAL_BUFFER_LENGTH = 400; let player = videojs(\"my_video_1\"); $('#sURL').on(\"keyup\", function(e) { if (e.keyCode == 13) { load_source(); } }); function load_source() { let url_string = document.getElementById(\"sURL\").value; console.log(url_string); player = videojs(\"my_video_1\"); player.src({ type: \"application/x-mpegURL\", src: url_string }); player.hlsQualitySelector(); player.ready(function() { let myPlayer = this; myPlayer.play(); }); }","link":"/hls2/index.html"}],"posts":[{"title":"这个视频被播放了xxx次","text":"本文可在Bilibili专栏阅读：cv7292636 前不久在YouTube上看到一则视频，来自著名YouTube艺人Tom Scott（B站搬运地址：BV1ZA411t7nK, YouTube地址：BxV14h0kFs0） &emsp;&emsp;这个视频有意思的地方在于，视频的标题准确“预测”了这个视频的播放量。对此，我很好奇他是怎么做到的，一番研究之后我有了答案，并且在B站也能轻易实现。原理只需要一句话就能概括：调用两次API，第一次通过HTTP的GET请求获得播放量，第二次通过POST将播放量更新至标题。下面我们一步一步来看。&emsp;&emsp;程序员小伙伴们对API一定不陌生，全称是应用程序编程接口。简单来说，它就是一部分预先定义的函数，我们无需了解函数具体的工作机制，只需根据接口的定义，就能轻松访问一组例程。下面这张图就展示了这个过程 &emsp;&emsp;不出所料，大家喜爱的B站也有“公开”的API哦。在Github上一番查找后，我决定使用以下两个Python库，分别来自@Passkou和@FortuneDayssss &emsp;&emsp;直接通过视频bv号调用视频信息API可以轻松获得播放量，具体代码如下， 123456789from bilibili_api import videofrom bilibiliuploader.bilibiliuploader import BilibiliUploaderimport osimport timeif __name__ == \"__main__\": bvid = \"BV1Hf4y1Q7CK\" v = video.get_video_info(bvid=bvid) views = v[\"stat\"][\"view\"] &emsp;&emsp;至此，第一步就完成了，仅仅用了10行代码。接下来是第二步，将播放量添加到标题。POST请求需要首先对用户身份进行验证，也就是用账号密码登录才能对自己视频进行标题变更操作。API同样提供了一个简单的接口，第一次通过账号密码登录后可以获得access token，之后使用access token登录，就可以对视频进行任意编辑操作了。 1234uploader = BilibiliUploader()dir_path = os.path.dirname(os.path.realpath(__file__))token_path = dir_path + \"/bililogin.json\"uploader.login_by_access_token_file(token_path) &emsp;&emsp;使用第一步获得的播放量，对标题进行编辑，再使用API发送POST请求更新就完成了。 123456parts = []uploader.edit( bvid=bvid, parts=parts, title='这个视频将会被播放' + str(views) + '次') &emsp;&emsp;最后，只需要在一定周期GET播放量，再POST新的标题就可以达到一种“预知”的效果了。这里就把周期设定为30秒，使用while循环执行，将脚本不间断运行在云服务器上。剩下的就是辛苦标题审核大大啦！小小完善后（控制更新频率）的完整代码如下， 123456789101112131415161718192021222324252627282930313233343536from bilibili_api import videofrom bilibiliuploader.bilibiliuploader import BilibiliUploaderimport os, timeif __name__ == \"__main__\": bvid = \"BV1Hf4y1Q7CK\" uploader = BilibiliUploader() dir_path = os.path.dirname(os.path.realpath(__file__)) token_path = dir_path + \"/bililogin.json\" prev_views = 0 while True: v = video.get_video_info(bvid=bvid) views = v[\"stat\"][\"view\"] if (views &gt; prev_views): uploader.login_by_access_token_file(token_path) if (views &lt; 10000): parts = [] uploader.edit( bvid=bvid, parts=parts, title=\"这个视频将会被播放\" + str(views) + \"次\" ) else: if (views - prev_views &gt; 1000): rounded_views = round(views / 10000, 1) parts = [] uploader.edit( bvid=\"BV1hD4y127PJ\", parts=parts, title=\"这个视频将会被播放\" + str(rounded_views) + \"万次\" ) prev_views = views time.sleep(30) 再次感谢@Passkou和@FortuneDayssss提供的API，有兴趣的小伙伴们也可以去支持一下他们哦。","link":"/2020/08/25/bilibili-title/"},{"title":"Linux Debian Repository结构及树莓派换源&#x2F;添加PPA","text":"在Debian以及其衍生的系统版本中，默认的软件包管理系统是 apt，一系列对软件的安装、卸载、升级等等操作都可以通过 apt执行。apt所需的获得软件列表、检查更新等操作依赖于软件源，这些源定义了从哪里去获得软件，源的URI定义在 /etc/apt/sources.list 文件以及 /etc/apt/sources.list.d 目录下。后者与前者的区别在于，前者为官方源文件，后者为一个目录，用于存放 .list 为结尾的文件，文件可任意命名，文件内容需遵循Debian定义的软件源文件格式。这个目录的主要目的就是方便增减额外的软件源，而不需要去改变官方源 sources.list，PPA (Personal Package Archive) 源文件通常会放在这个目录下。当然，将自定义软件源的URI添加到 sources.list也是起到同样的效果，但通常不这么做。下面两图分别展示了两者的内容。 Debian Repo Format通过查看 man page ，软件源格式定义如下， 1deb uri distribution [component1] [component2] [...] deb 声明了binary package的源，使用 deb-src 声明source package。binary package为编译完成的二进制文件，source package为所有源文件，需build from source，即在本地编译。 uri 声明软件源的根目录位置，例如树莓派交大源的URI http://mirrors.sjtug.sjtu.edu.cn/raspbian/raspbian/. distribution 声明了 $ARCHIVE_ROOT/dists 之下的子目录。以上方左图为例，distribution 为 buster，则子目录位置为 http://mirrors.sjtug.sjtu.edu.cn/raspbian/raspbian/dists/buster/. component 则为更深层的子目录，例如在树莓派Pi OS下有 main, non-free, contrib, 以及rpi。在Ubuntu下，主要有以下四种 Main - Canonical-supported free and open-source software. Universe - Community-maintained free and open-source software. Restricted - Proprietary drivers for devices. Multiverse - Software restricted by copyright or legal issues. 更多相关信息可查看 https://wiki.debian.org/DebianRepository/Format. 更换国内源国内访问官方源速度缓慢，因此会通常把官方源更换成国内镜像，一些高校、企业会有免费镜像站，可任意选择，替换 sources.list 内的文件即可。如Ubuntu，比较多人用的有清华源，阿里源等等。树莓派国内也有众多高校提供源，可通过官方链接查询。以树莓派Pi OS (buster)举例，个人使用的是交大源，做出如下变更。 123456# 编辑 `/etc/apt/sources.list` 文件，删除原文件所有内容，用以下内容取代：deb http://mirrors.sjtug.sjtu.edu.cn/raspbian/raspbian/ buster main non-free contrib rpideb-src http://mirrors.sjtug.sjtu.edu.cn/raspbian/raspbian/ buster main non-free contrib rpi# 编辑 `/etc/apt/sources.list.d/raspi.list` 文件，删除原文件所有内容，用以下内容取代：deb http://mirrors.sjtug.sjtu.edu.cn/raspberrypi/ buster main ui 关于添加PPA (Personal Package Archive)之前提到了PPA，顾名思义，通常为软件发行方自行管理的软件仓库。PPA为 .list 文件，并存放在 sources.list.d 目录下。使用如下方式即可， 1add-apt-repository [options] repository 其中 repository 为PPA格式 ppa:&lt;user&gt;/&lt;ppa-name&gt;。通常软件安装指导会提供详细步骤。","link":"/2020/12/25/pi-source-list/"},{"title":"Sadowsocks 客户端&#x2F;服务端配置","text":"服务端 方式一 在目标服务器上用自动化安装脚本配置Shadowsocks: Github repo. 根据脚本提示配置端口、密码、加密等等。 后续如需编辑端口号、密码等信息，直接编辑/etc/shadowsocks.json即可。 注：脚本需要从GitHub进行wget，确认ca-certificates和ssl-cert已安装。 方式二 使用官方 shadowsocks-libev 提供的docker容器，直接从docker hub上pull镜像: shadowsocks/shadowsocks-libev/，同方式一编辑/etc/shadowsocks-libev/config.json配置端口号密码等信息后，启动docker镜像即可。 方式三 以Ubuntu为例，直接安装或Build from source。详细参照官方文档： shadowsocks-libev README 12sudo apt updatesudo apt install shadowsocks-libev 配置文件位置同方式二，启动使用如下脚本 1sudo systemctl start shadowsocks-libev.service 开机自启 1sudo systemctl enable shadowsocks-libev.service 配置文件举例12345678{ \"server\":\"0.0.0.0\", \"server_port\":8388, \"password\":\"password\", \"timeout\":60, \"method\":\"aes-128-gcm\", \"mode\":\"tcp_and_udp\"} 客户端根据操作系统下载对应客户端即可，客户端配置输入目标服务器的IP、端口号、加密方式、密码等信息即可建立连接。官方客户端链接：https://shadowsocks.org/en/download/clients.html 代理配置文件翻墙直接使用默认配置文件即可，按需增减规则。若回国，根据操作系统平台可使用以下代理配置，收集自网络，经过自行编辑，按需增减规则 Windows: https://raw.githubusercontent.com/shuy98/ss_rule/master/pac.txt Android: https://raw.githubusercontent.com/shuy98/ss_rule/master/rule.txt iOS Shadowrocket: https://raw.githubusercontent.com/shuy98/ss_rule/master/go_home.conf","link":"/2020/09/08/ss-rule/"},{"title":"配置自己的流媒体服务：关于MPEG-DASH&#x2F;HLS","text":"自从开始使用云服务器之后，因为内网带宽非常好，便经常会在服务器上直接下载视频。观看视频通常有两个选择，一个便是下载到本地然后使用本地播放器播放，另一个是直接用http请求视频文件（如MP4），在浏览器直接播放。两者都有各自的缺点，也不符合如今主流的流媒体播放方式。这篇文章会重点讲讲流媒体所使用的 MPEG-DASH/HLS，以及如何在自己的服务器上进行配置。 相关名词码率/比特率（Bitrate）: 单位时间内传输的信息，通常用 bps (bit per second)表示。视频码率可以理解为单位时间内传输的数据越多，画面包含的细节信息越多，质量也就越高。分辨率（Resolution）: 每帧画面像素点的数量。常见的如 720P (1280x720)、1080P (1920x1080)都是这个含义。高分辨率不代表高画质，若码率较低，画面会有糊成一团的观感。帧率（FPS）: 每秒钟包含的帧数。常见的有24帧、60帧等等。帧率越高画面越连贯丝滑。 网络视频播放技术HTTP Download最初的方式，浏览器请求资源，资源下载完成后由本地播放器进行播放。优点是架构非常简单，缺点是必须等待完整视频下载完成后才能开始播放。 HTTP Progressive Download对之前的方式的改进，不再是浏览器与服务交换信息，而是播放器直接与服务器建立TCP连接，好处在于只要有足够的视频帧，就可以直接开始播放视频，无需等待整部视频下载完成。预先下载的视频帧会放在缓冲区（Buffer）内。播放器与服务器的连接依赖 Meta File，该文件由浏览器先向服务器发起请求获得。根据下图表示，大体上为三步， 浏览器向服务器请求 Meta File，该文件描述了视频相关的信息。 浏览器传递 Meta File 给媒体播放器。 媒体播放器读取 Meta File 信息，并与服务器建立TCP连接、请求视频文件。 这里开始引入视频缓冲（Buffer），在边下载边播放时要保证缓冲区有足够的视频帧，否则就会出现我们看到的视频卡顿现象，以等待缓存区积累一定数量的视频帧后继续播放视频。 Progressive Download 也有着明显的缺点，一个是对seek不友好，比如要随意定位到视频的某个时间点，会出现长时间等待来下载额外不需要的视频帧。而且无法实时改变视频码率来适应不同的网络状况，通常要在的下载之前确定视频的码率。之后的HTTP Streaming就解决了这些问题。 Real-Time Streaming (RTSP)第二代技术，实时流媒体协议，为L7应用层协议，不同于HTTP协议。RTSP允许TCP或UDP做为控制信息的传输协议。大体上架构设计与Progressive Download非常类似。RTSP属于一种Custom Streaming Protocol，缺点也十分明显，例如路由器可能会处于安全原因阻止非HTTP的协议，防火墙阻止UDP协议，无法利用HTTP代理和缓存的优势等等。这些都会导致Custom Streaming Protocol无法很好地适应复杂的互联网环境。 HTTP Streaming第三代技术，适应性的流媒体播放技术，也是如今主流的流媒体播放网站所使用的。该架构以客户端为核心，完全使用标准的Web Server服务和HTTP协议，即stateless server，以及stateful client。视频被分成多个时长相同的分段（Chunk），每个分段都始于关键帧（Keyframe）来保证互相独立。客户端按需下载视频分段，再按顺序播放来观看连续视频。 Adaptive Bit Rate 可对视频分段进行不同码率的编码，码率越高画面损失越小，文件体积也就越大，再根据不同客户的网络带宽，适应性选择对应的版本。很多视频网站都支持清晰度选择，例如流畅、清晰、高清，超清等等，就是这个道理。因为Chunk Boundary相同，不同码率的视频可以无缝衔接。这就能够让高带宽的网络选择码率更高的视频，也能让低带宽的网络流畅播放码率较低的视频。 举个具体的例子，例如一个视频分段的长度为10秒钟，将其编码为三个版本：流畅、高清，和超清，体积大小分别对应20Mb、50Mb, 还有100Mb。从应用程序的角度出发，网络带宽是不可见的，只能通过下载一个分段的大小和时间来估计。假设下载20Mb的分段用了4秒钟，我们就可以估计网络带宽大约为5Mbps。根据此估计来选择下一个要下载分段的码率。可以有很多不同的适应性算法，这里不介绍。 实现这一切同样依赖于一个 Manifest File，该描述文件记录了视频时长、分段码率、分段URL等信息，客户端根据这个文件对对应的分段发起请求，流程如下图所示。 HTTP Streaming 有一个很大的优势在于它使用了互联网广泛使用的HTTP协议和Web Server架构，使得它可以利用现存的防火墙、缓存、代理、CDN等带来的优势。同时它将大的视频文件细分成多个小型且独立分段和多种码率选择，对Seek以及不同的网络环境非常友好。例如来自Apple的HTTP Live Streaming (HLS)，还有Dynamic Adaptive Streaming over HTTP (MPEG-DASH)都是现在广泛使用的协议。 HLS实现搭建的环境及依赖如下， 平台： Ubuntu 18.04 LTSWeb Server： Nginx 1.14.0依赖： ffmpeg v3.4.8 videojs/http-streaming v2.4.1 videojs-contrib-quality-levels v2.0.9 videojs-hls-quality-selector v1.1.4 这里选用了videojs/http-streaming，它提供了播放器的封装和简单易用的API，只需声明Manifest File的地址即可播放HSL协议的视频，核心代码如下，具体Demo详见 https://shuy98.top/hls2/ 1234567891011121314&lt;!-- HTML --&gt;&lt;div&gt; &lt;video-js name=\"videoElement\" id=\"my_video_1\" class=\"vjs-default-skin vjs-big-play-centered\" controls preload=\"none\" width=\"1280\" height=\"720\" &gt; &lt;source id=\"source_url\" src=\"\" type=\"application/x-mpegURL\" /&gt; &lt;/video-js&gt;&lt;/div&gt; videojs-contrib-quality-levels和videojs-hls-quality-selector则提供了清晰度选项的API。 12345678// JavaScriptplayer = videojs(\"my_video_1\");player.src({ type: \"application/x-mpegURL\", src: url_string });player.hlsQualitySelector();player.ready(function() { let myPlayer = this; myPlayer.play();});","link":"/2021/01/04/dash-hls/"},{"title":"树莓派Raspberry Pi OS Lite安装远程桌面VNC&#x2F;RDP","text":"使用的树莓派版本为4B，2G内存，Raspberry Pi OS Lite Buster，安装之前先进行更新 1sudo apt update &amp;&amp; sudo apt full-upgrade -y &amp;&amp; sudo apt clean 选择合适自己的桌面GUI，树莓派默认的桌面为PIXEL，Lite系统使用下面这个命令直接安装，Desktop无需再安装 1sudo apt install raspberrypi-ui-mods 也可选择其他桌面环境如xfce， 1sudo apt-get install xfce4 xfce4-terminal 关于各个GUI的详细比较可参照官方教程。 使用VNC远程访问桌面首先配置树莓派开启VNC服务，树莓派已自带RealVNC 1sudo raspi-config 进入 Interface Options -&gt; VNC -&gt; Enable，调整显示分辨率 Display Options -&gt; Resolution.设置完成后重启机器，VNC配置完成。接下来只需根据所使用的平台下载VNC客户端，树莓派推荐使用RealVNC Viewer，输入树莓派的IP地址即可连接远程桌面。 使用RDP远程访问桌面RDP是由Microsoft开发的协议，Windows下可直接使用Remote Desktop客户端连接，无需额外安装。 1sudo apt-get install xrdp 默认端口为3389，可通过配置文件更改 /etc/xrdp/xrdp.ini。客户端使用 IP:Port即可连接远程桌面。以下为控制命令 123456sudo service xrdp status # 查看状态sudo service xrdp start # 启动服务sudo service xrdp stop # 停止服务sudo service xrdp restart # 重启服务sudo update-rc.d xrdp disable # 关闭开机自启sudo update-rc.d xrdp enable # 开启开机自启","link":"/2020/12/21/pi-VNC-RDP/"},{"title":"Nginx下如何获取SSL&#x2F;TLS泛域名证书","text":"什么是SSL/TLS我们浏览网页的时候，大部分网页的URL边上会有一个锁的标志，这表面我们与该服务器之间的连接是安全的。将流量加密是一种保证连接安全的手段，就算被劫持，流量中的隐私信息也不会被泄露。SSL/TLS协议就是为了达到这样的目的。现如今信息安全很重要，因此越来越多的网站会默认使用SSL/TLS来保证与客户间的通信安全。HTTPS使用了SSL/TLS进行流量加密，默认443端口。 加密方式SSL会用到两种主要的加密方式：对称加密、非对称加密。对称加密只使用一把key，这把key同时用于加密和解密。非对称加密使用一对key，私匙(Private Key)和公匙(Public Key)。Public Key，顾名思义是公开的Key，能用于解密其对应Private Key加密的密文。举个例子，有信息X，以及一对Key，X_pub和X_priv。可以用其中一把(例如X_priv)对信息进行加密得到X的密文，并用另外一把(例如X_pub)对信息进行解密得到X。非堆成加密效率低于对称加密。 证书颁发机构CA（Certificate Authority）CA会使用其Private Key将网站相关信息加密，并颁发证书Certificate。CA的Public Key已经预加载在操作系统或浏览器中，可以直接解密证书获取站点信息。企业会向部分CA付费获取专门的服务，当然也有免费的CA如Let’s Encrypt。 证书（Certificate）包含站点的相关信息，如DNS Name，Public Key，CA Name，其他相关信息，以及CA签名。CA的签名就是CA使用其Private Key对上述所有信息进行加密后得到的密文，可通过CA的Public解密。 TLS1.2握手过程有了以上部分，信息加密便可通过证书轻松实现了，具体流程如下。 TLS建立在TCP之上，因此先完成常规的TCP三次握手。 ClientHello: 客户端发起“hello”请求，包含支持的TLS最高版本，支持的cipher suites(加密算法列表)，以及一串随机的字节client random。 ServerHello: 服务端回复请求，包含证书，服务端选择使用的cipher suite，以及一串随机的字节server random。 Authentication: 客户端通过证书确认服务端身份，使用CA的Public Key解密证书签名，以获取服务端Public Key。 The premaster secret: 客户端发送一串或多串随机字节，作为“premaster secret”。这段信息使用服务端的Public Key加密，只能通过服务端的Private Key解密。 Private key used: 服务端使用Private Key解密得到premaster secret。 Session Key: 双方可使用client random、server random，以及premaster secret生成相同的session/secret key。 Client ready: 客户端发送Finished，包含此前全部信息，并使用session key加密。这是第一段使用session key加密的信息。 Server ready: 服务端同样发送Finished，包含此前全部信息，并使用session key加密。 握手完成，连接建立完毕，双方使用session key对信息进行对称加密，继续后续通信。 并非所有TLS握手会用到private key来生成session key，详见Diffie-Hellman handshake process。以上保证了客户端和服务端之间的通信安全。证书和握手这个过程保证了站点不可被仿冒。浏览器若提示网站证书有问题，并且我们会和网站交换敏感信息，一定要确认网站安全。 获取个人泛域名的SSL/TLS证书（Let’s Encrypt）这里我们使用知名的免费的CA：Let’s Encrypt，并借助certbot自动获取证书。 123sudo add-apt-repository ppa:certbot/certbotsudo apt-get updatesudo apt-get install python-certbot-nginx 使用一下命令直接获得泛域名证书，将example.com替换为自己的域名 1sudo certbot --server https://acme-v02.api.letsencrypt.org/directory -d *.example.com --manual --preferred-challenges dns-01 certonly 将生成的DNS TXT部署到域名DNS管理页面下即可。证书会放在/etc/letsencrypt/live/example.com/目录下，将Nginx配置文件中的证书位置指向该目录即可。 注意：证书的有效期限为3个月，临近到期时使用以上命令renew或直接在命令行执行certbot renew，也有自动renew方法，这里不描述。证书更新后需reload Web Server以加载新的证书。","link":"/2020/09/30/ssl-nginx/"}],"tags":[{"name":"API","slug":"API","link":"/tags/API/"},{"name":"树莓派","slug":"树莓派","link":"/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"科学上网","slug":"科学上网","link":"/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"}],"categories":[{"name":"不正经的内容","slug":"不正经的内容","link":"/categories/%E4%B8%8D%E6%AD%A3%E7%BB%8F%E7%9A%84%E5%86%85%E5%AE%B9/"},{"name":"正经的内容","slug":"正经的内容","link":"/categories/%E6%AD%A3%E7%BB%8F%E7%9A%84%E5%86%85%E5%AE%B9/"}]}